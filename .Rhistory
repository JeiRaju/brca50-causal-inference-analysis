selected_genes
# Create a simple CPT example from gRain practical
yn <- c("yes", "no")
a <- cptable(~asia, values=c(1,99), levels=yn)
t.a <- cptable(~tub|asia, values=c(5,95,1,99), levels=yn)
plist <- compileCPT(list(a, t.a))
net1 <- grain(plist)
plot(net1)
# Query marginal probabilities
querygrain(net1, nodes=c("asia", "tub"), type="marginal")
setwd("~/UNISA/Advance Analytic Techniques/Assignments/Project/brca50-causal-inference-analysis")
# Load only in-syllabus libraries from provided practicals
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
# Required for Bayesian Network structure learning and inference
library(bnlearn)
library(pcalg)
library(gRain)
# Load only in-syllabus libraries from provided practicals
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
# Required for Bayesian Network structure learning and inference
library(bnlearn)
library(pcalg)
library(gRain)
# Load and preprocess dataset
data <- read.csv("BRCA_RNASeqv2_top50.csv")
V <- colnames(data)  # Variable names
gene_data <- data[ , colnames(data) != "class"]
# Learn the Bayesian network using Hill-Climbing
bn_hc <- hc(gene_data)
plot(bn_hc)
library(pcalg)
library(bnlearn)
library(Rgraphviz)
library(e1071)
library(caret)
library(gRain)
library(pcalg)
library(bnlearn)
library(Rgraphviz)
library(e1071)
library(caret)
library(gRain)
# Load the BRCA RNASeqv2 data from the CSV file
brca50 <- read.csv("BRCA_RNASeqv2_top50.csv")
# Exclude the class variable in building the network
brca50_data <- brca50[, -which(names(brca50) == "class")]
# Load the BRCA RNASeqv2 data from the CSV file
brca50 <- read.csv("BRCA_RNASeqv2_top50.csv")
# Exclude the class variable in building the network
brca50_data <- brca50[, -which(names(brca50) == "class")]
# Use the PC algorithm to find the causal structure
n <- nrow(brca50_data)
V <- colnames(brca50_data)  # Variable names
suffStat <- list(C = cor(brca50_data), n = n)
# Estimate CPDAG using the PC algorithm
pc.fit <- pc(suffStat = suffStat, indepTest = gaussCItest, alpha = 0.05, labels = V)
# Visualizing the network
if (require(Rgraphviz)) {
par(mfrow = c(1, 2))
plot(pc.fit, main = "Estimated CPDAG")
}
# Use the PC algorithm to estimate the causal graph
suffStat <- list(C = cor(brca50_data), n = nrow(brca50_data))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.01, p = ncol(brca50_data))
# Find the index of EBF1 in the dataset
ebf1_index <- which(colnames(brca50_data) == "EBF1")
# Initialize an empty list to store causal effects
causal_effects_list <- list()
# Calculate causal effects of all other genes on EBF1 using IDA
for (i in 1:ncol(brca50_data)) {
if (i != ebf1_index) { # Exclude EBF1 itself
# IDA on each gene with respect to EBF1
effects <- ida(i, ebf1_index, cov(brca50_data), pc.fit@graph)
# Store the minimum absolute effect for each gene
causal_effects_list[[i]] <- min(abs(effects))
} else {
causal_effects_list[[i]] <- NA
}
}
# Convert the list to a vector for easier manipulation
causal_effects <- unlist(causal_effects_list)
# Rank the genes based on the absolute value of their causal effects
# Ignore NA values which correspond to EBF1 itself
sorted_indices <- order(causal_effects, decreasing = TRUE, na.last = NA)
# Get the top 10 genes
top_10_indices <- sorted_indices[1:10]
top_10_genes <- colnames(brca50_data)[top_10_indices]
top_10_effects <- causal_effects[top_10_indices]
# Create a data frame to display the top 10 genes and their effects
top_10_genes_df <- data.frame(Gene = top_10_genes, Causal_Effect = top_10_effects)
top_10_genes_df
# Ensure that brca50_data is a data frame
brca50_data <- data.frame(brca50_data)
# Use the learn.nbr function to find the Markov blanket of ABCA9 using si.hiton.pc method
# Identify the column name for ABCA9
abca9_name <- "ABCA9"
# Applying si.hiton.pc algorithm to find the Markov blanket of ABCA9
HITON_PC_ABCA9 <- learn.nbr(brca50_data, node = abca9_name, method = "si.hiton.pc", alpha = 0.01)
HITON_PC_ABCA9
# Learn the Markov blanket of node 7
MB.ABCA9 <- learn.mb(brca50_data, node = abca9_name, method = "iamb", alpha = 0.01)
# Display the Markov blanket
print(MB.ABCA9)
# Calculate the average expression value of all genes
average_expression <- mean(as.matrix(brca50_data), na.rm = TRUE)
# Discretize the dataset
# If the expression level is greater than or equal to the average, set it to 1, otherwise 0
discretised_data <- as.data.frame(lapply(brca50_data, function(x) ifelse(x >= average_expression, 1, 0)))
# R Code to Find Parent and Children Set Using PC-Simple
# Extract the class column from the original dataset
class_column <- brca50$class
# Add the class column to the discretized dataset
discretised_data$class <- class_column
# Convert class variable to a factor for classification
discretised_data$class <- as.factor(discretised_data$class)
# Display the first few rows of the updated discretized dataset
head(discretised_data)
# Define the target variable (class)
target_variable <- "class"
# Ensure the dataset is in matrix format without the class variable
brca50_data_matrix <- as.matrix(discretised_data[, -which(names(discretised_data) == target_variable)])
# Define the class column separately
class_column <- discretised_data$class
# Use the pcSelect function to find the parent and children set of the class variable
# pcSelect takes the matrix of predictors, the target variable (class), and significance level (alpha)
pc_simple_result <- pcSelect(class_column, brca50_data_matrix, alpha = 0.01)
pc_simple_result
# 1. Naive Bayes classification using all genes
# Prepare the data by excluding the class variable from the predictors
all_features_data <- discretised_data[, -which(names(discretised_data) == "class")]
class_column <- discretised_data$class
# Perform 10-fold cross-validation using all features
set.seed(123) # For reproducibility
folds <- createFolds(class_column, k = 10)
cv_results_all <- lapply(folds, function(train_index) {
# Split the data
train_data <- all_features_data[train_index, ]
test_data <- all_features_data[-train_index, ]
train_class <- class_column[train_index]
test_class <- class_column[-train_index]
# Train the Naive Bayes model
nb_model <- naiveBayes(train_data, train_class)
# Make predictions
predictions <- predict(nb_model, test_data)
# Calculate accuracy
accuracy <- mean(predictions == test_class)
return(accuracy)
})
# Average accuracy for all features
mean_accuracy_all <- mean(unlist(cv_results_all))
pc_set_genes <- colnames(brca50_data)[which(pc_simple_result$G == 1)] # Extract genes from the PC set
# Subset the dataset to include only the parent and children set
pc_set_data <- discretised_data[, c(pc_set_genes, "class")]
# Perform 10-fold cross-validation using only the PC set features
cv_results_pc <- lapply(folds, function(train_index) {
# Split the data
train_data <- pc_set_data[train_index, -which(names(pc_set_data) == "class")]
test_data <- pc_set_data[-train_index, -which(names(pc_set_data) == "class")]
train_class <- pc_set_data$class[train_index]
test_class <- pc_set_data$class[-train_index]
# Train the Naive Bayes model
nb_model <- naiveBayes(train_data, train_class)
# Make predictions
predictions <- predict(nb_model, test_data)
# Calculate accuracy
accuracy <- mean(predictions == test_class)
return(accuracy)
})
# Average accuracy for the PC set
mean_accuracy_pc <- mean(unlist(cv_results_pc))
cat("Accuracy using all features (genes):", mean_accuracy_all * 100, "\n")
cat("Accuracy using only the parent and children set (PC set):", mean_accuracy_pc * 100, "\n")
# Steps to Construct Conditional Probability Tables
# Extract the class column from the original dataset
class_column <- brca50$class
# Add the class column to the discretized dataset
discretised_data$class <- class_column
# Map 'N' and 'C' to binary values (e.g., N = 0, C = 1)
discretised_data$class <- ifelse(discretised_data$class == "N", 0, 1)
# Convert class variable to a factor for classification
discretised_data$class <- as.factor(discretised_data$class)
head(discretised_data)
# Calculate the marginal probabilities for BTNL9
btln9_high_count <- sum(discretised_data$BTNL9 == 1)  # Assuming 1 represents high expression
btln9_low_count <- sum(discretised_data$BTNL9 == 0)   # Assuming 0 represents low expression
total_samples <- nrow(discretised_data)
# Calculate the probabilities
p_btln9_high <- btln9_high_count / total_samples
p_btln9_low <- btln9_low_count / total_samples
# Display the probabilities
cat("P(BTNL9 = High):", p_btln9_high, "\n")
cat("P(BTNL9 = Low):", p_btln9_low, "\n")
# Calculate the conditional probabilities for CD300LG given BTNL9
cd300lg_high_btln9_high <- sum(discretised_data$CD300LG == 1 & discretised_data$BTNL9 == 1)
cd300lg_low_btln9_high <- sum(discretised_data$CD300LG == 0 & discretised_data$BTNL9 == 1)
cd300lg_high_btln9_low <- sum(discretised_data$CD300LG == 1 & discretised_data$BTNL9 == 0)
cd300lg_low_btln9_low <- sum(discretised_data$CD300LG == 0 & discretised_data$BTNL9 == 0)
# Calculate conditional probabilities
p_cd300lg_high_given_btln9_high <- cd300lg_high_btln9_high / (cd300lg_high_btln9_high + cd300lg_low_btln9_high)
p_cd300lg_low_given_btln9_high <- cd300lg_low_btln9_high / (cd300lg_high_btln9_high + cd300lg_low_btln9_high)
p_cd300lg_high_given_btln9_low <- cd300lg_high_btln9_low / (cd300lg_high_btln9_low + cd300lg_low_btln9_low)
p_cd300lg_low_given_btln9_low <- cd300lg_low_btln9_low / (cd300lg_high_btln9_low + cd300lg_low_btln9_low)
# Display the conditional probabilities
cat("P(CD300LG = High | BTNL9 = High):", p_cd300lg_high_given_btln9_high, "\n")
cat("P(CD300LG = Low | BTNL9 = High):", p_cd300lg_low_given_btln9_high, "\n")
cat("P(CD300LG = High | BTNL9 = Low):", p_cd300lg_high_given_btln9_low, "\n")
cat("P(CD300LG = Low | BTNL9 = Low):", p_cd300lg_low_given_btln9_low, "\n")
# Calculate the conditional probabilities for class given CD300LG
class_cancer_cd300lg_high <- sum(discretised_data$class == 1 & discretised_data$CD300LG == 1)
class_no_cancer_cd300lg_high <- sum(discretised_data$class == 0 & discretised_data$CD300LG == 1)
class_cancer_cd300lg_low <- sum(discretised_data$class == 1 & discretised_data$CD300LG == 0)
class_no_cancer_cd300lg_low <- sum(discretised_data$class == 0 & discretised_data$CD300LG == 0)
# Calculate conditional probabilities
p_class_cancer_given_cd300lg_high <- class_cancer_cd300lg_high / (class_cancer_cd300lg_high + class_no_cancer_cd300lg_high)
p_class_no_cancer_given_cd300lg_high <- class_no_cancer_cd300lg_high / (class_cancer_cd300lg_high + class_no_cancer_cd300lg_high)
p_class_cancer_given_cd300lg_low <- class_cancer_cd300lg_low / (class_cancer_cd300lg_low + class_no_cancer_cd300lg_low)
p_class_no_cancer_given_cd300lg_low <- class_no_cancer_cd300lg_low / (class_cancer_cd300lg_low + class_no_cancer_cd300lg_low)
# Display the conditional probabilities
cat("P(class = Cancer | CD300LG = High):", p_class_cancer_given_cd300lg_high, "\n")
cat("P(class = No Cancer | CD300LG = High):", p_class_no_cancer_given_cd300lg_high, "\n")
cat("P(class = Cancer | CD300LG = Low):", p_class_cancer_given_cd300lg_low, "\n")
cat("P(class = No Cancer | CD300LG = Low):", p_class_no_cancer_given_cd300lg_low, "\n")
# Calculate the conditional probabilities for IGSF10 given class
igsf10_high_class_cancer <- sum(discretised_data$IGSF10 == 1 & discretised_data$class == 1)
igsf10_low_class_cancer <- sum(discretised_data$IGSF10 == 0 & discretised_data$class == 1)
igsf10_high_class_no_cancer <- sum(discretised_data$IGSF10 == 1 & discretised_data$class == 0)
igsf10_low_class_no_cancer <- sum(discretised_data$IGSF10 == 0 & discretised_data$class == 0)
# Calculate conditional probabilities
p_igsf10_high_given_class_cancer <- igsf10_high_class_cancer / (igsf10_high_class_cancer + igsf10_low_class_cancer)
p_igsf10_low_given_class_cancer <- igsf10_low_class_cancer / (igsf10_high_class_cancer + igsf10_low_class_cancer)
p_igsf10_high_given_class_no_cancer <- igsf10_high_class_no_cancer / (igsf10_high_class_no_cancer + igsf10_low_class_no_cancer)
p_igsf10_low_given_class_no_cancer <- igsf10_low_class_no_cancer / (igsf10_high_class_no_cancer + igsf10_low_class_no_cancer)
# Display the conditional probabilities
cat("P(IGSF10 = High | class = Cancer):", p_igsf10_high_given_class_cancer, "\n")
cat("P(IGSF10 = Low | class = Cancer):", p_igsf10_low_given_class_cancer, "\n")
cat("P(IGSF10 = High | class = No Cancer):", p_igsf10_high_given_class_no_cancer, "\n")
cat("P(IGSF10 = Low | class = No Cancer):", p_igsf10_low_given_class_no_cancer, "\n")
# Calculate the conditional probabilities for ABCA9 given BTNL9 and IGSF10
abca9_high_btln9_high_igsf10_high <- sum(discretised_data$ABCA9 == 1 & discretised_data$BTNL9 == 1 & discretised_data$IGSF10 == 1)
abca9_low_btln9_high_igsf10_high <- sum(discretised_data$ABCA9 == 0 & discretised_data$BTNL9 == 1 & discretised_data$IGSF10 == 1)
abca9_high_btln9_high_igsf10_low <- sum(discretised_data$ABCA9 == 1 & discretised_data$BTNL9 == 1 & discretised_data$IGSF10 == 0)
abca9_low_btln9_high_igsf10_low <- sum(discretised_data$ABCA9 == 0 & discretised_data$BTNL9 == 1 & discretised_data$IGSF10 == 0)
abca9_high_btln9_low_igsf10_high <- sum(discretised_data$ABCA9 == 1 & discretised_data$BTNL9 == 0 & discretised_data$IGSF10 == 1)
abca9_low_btln9_low_igsf10_high <- sum(discretised_data$ABCA9 == 0 & discretised_data$BTNL9 == 0 & discretised_data$IGSF10 == 1)
abca9_high_btln9_low_igsf10_low <- sum(discretised_data$ABCA9 == 1 & discretised_data$BTNL9 == 0 & discretised_data$IGSF10 == 0)
abca9_low_btln9_low_igsf10_low <- sum(discretised_data$ABCA9 == 0 & discretised_data$BTNL9 == 0 & discretised_data$IGSF10 == 0)
# Calculate conditional probabilities
p_abca9_high_given_btln9_high_igsf10_high <- abca9_high_btln9_high_igsf10_high / (abca9_high_btln9_high_igsf10_high + abca9_low_btln9_high_igsf10_high)
p_abca9_low_given_btln9_high_igsf10_high <- abca9_low_btln9_high_igsf10_high / (abca9_high_btln9_high_igsf10_high + abca9_low_btln9_high_igsf10_high)
p_abca9_high_given_btln9_high_igsf10_low <- abca9_high_btln9_high_igsf10_low / (abca9_high_btln9_high_igsf10_low + abca9_low_btln9_high_igsf10_low)
p_abca9_low_given_btln9_high_igsf10_low <- abca9_low_btln9_high_igsf10_low / (abca9_high_btln9_high_igsf10_low + abca9_low_btln9_high_igsf10_low)
p_abca9_high_given_btln9_low_igsf10_high <- abca9_high_btln9_low_igsf10_high / (abca9_high_btln9_low_igsf10_high + abca9_low_btln9_low_igsf10_high)
p_abca9_low_given_btln9_low_igsf10_high <- abca9_low_btln9_low_igsf10_high / (abca9_high_btln9_low_igsf10_high + abca9_low_btln9_low_igsf10_high)
p_abca9_high_given_btln9_low_igsf10_low <- abca9_high_btln9_low_igsf10_low / (abca9_high_btln9_low_igsf10_low + abca9_low_btln9_low_igsf10_low)
p_abca9_low_given_btln9_low_igsf10_low <- abca9_low_btln9_low_igsf10_low / (abca9_high_btln9_low_igsf10_low + abca9_low_btln9_low_igsf10_low)
# Display the conditional probabilities
cat("P(ABCA9 = High | BTNL9 = High, IGSF10 = High):", p_abca9_high_given_btln9_high_igsf10_high, "\n")
cat("P(ABCA9 = Low | BTNL9 = High, IGSF10 = High):", p_abca9_low_given_btln9_high_igsf10_high, "\n")
cat("P(ABCA9 = High | BTNL9 = High, IGSF10 = Low):", p_abca9_high_given_btln9_high_igsf10_low, "\n")
cat("P(ABCA9 = Low | BTNL9 = High, IGSF10 = Low):", p_abca9_low_given_btln9_high_igsf10_low, "\n")
cat("P(ABCA9 = High | BTNL9 = Low, IGSF10 = High):", p_abca9_high_given_btln9_low_igsf10_high, "\n")
cat("P(ABCA9 = Low | BTNL9 = Low, IGSF10 = High):", p_abca9_low_given_btln9_low_igsf10_high, "\n")
cat("P(ABCA9 = High | BTNL9 = Low, IGSF10 = Low):", p_abca9_high_given_btln9_low_igsf10_low, "\n")
cat("P(ABCA9 = Low | BTNL9 = Low, IGSF10 = Low):", p_abca9_low_given_btln9_low_igsf10_low, "\n")
# Define binary levels: "High" and "Low" for gene expression
yn <- c("High", "Low")
# CPT for BTNL9
btln9_cpt <- cptable(~BTNL9, values=c(p_btln9_high, p_btln9_low), levels=yn)
# CPT for CD300LG given BTNL9
cd300lg_cpt <- cptable(~CD300LG | BTNL9,
values=c(p_cd300lg_high_given_btln9_high,
p_cd300lg_low_given_btln9_high,
p_cd300lg_high_given_btln9_low,
p_cd300lg_low_given_btln9_low),
levels=yn)
# CPT for class given CD300LG
class_cpt <- cptable(~class | CD300LG,
values=c(p_class_cancer_given_cd300lg_high,
p_class_no_cancer_given_cd300lg_high,
p_class_cancer_given_cd300lg_low,
p_class_no_cancer_given_cd300lg_low),
levels=c("Cancer", "No_Cancer"))
# CPT for IGSF10 given class
igsf10_cpt <- cptable(~IGSF10 | class,
values=c(p_igsf10_high_given_class_cancer,
p_igsf10_low_given_class_cancer,
p_igsf10_high_given_class_no_cancer,
p_igsf10_low_given_class_no_cancer),
levels=yn)
# CPT for ABCA9 given BTNL9 and IGSF10
abca9_cpt <- cptable(~ABCA9 | BTNL9 * IGSF10,
values=c(p_abca9_high_given_btln9_high_igsf10_high,
p_abca9_low_given_btln9_high_igsf10_high,
p_abca9_high_given_btln9_high_igsf10_low,
p_abca9_low_given_btln9_high_igsf10_low,
p_abca9_high_given_btln9_low_igsf10_high,
p_abca9_low_given_btln9_low_igsf10_high,
p_abca9_high_given_btln9_low_igsf10_low,
p_abca9_low_given_btln9_low_igsf10_low),
levels=yn)
plist <- compileCPT(list(btln9_cpt, cd300lg_cpt, class_cpt, igsf10_cpt, abca9_cpt))
plist
bn <- grain(plist)
# Query marginal probability of BTNL9
marginal_btln9 <- querygrain(bn, nodes=c("BTNL9"), type="marginal")
marginal_btln9
# Query conditional probability P(CD300LG | BTNL9)
conditional_cd300lg_given_btln9 <- querygrain(bn, nodes=c("CD300LG", "BTNL9"), type="conditional")
print(conditional_cd300lg_given_btln9)
# Query conditional probability P(class | CD300LG)
conditional_class_given_cd300lg <- querygrain(bn, nodes=c("class", "CD300LG"), type="conditional")
print(conditional_class_given_cd300lg)
# Query conditional probability P(IGSF10 | class)
conditional_igsf10_given_class <- querygrain(bn, nodes=c("IGSF10", "class"), type="conditional")
print(conditional_igsf10_given_class)
# Query conditional probability P(ABCA9 | BTNL9, IGSF10)
conditional_abca9_given_btln9_igsf10 <- querygrain(bn, nodes=c("ABCA9", "BTNL9", "IGSF10"), type="conditional")
print(conditional_abca9_given_btln9_igsf10)
# Query joint probability for BTNL9, CD300LG, IGSF10, and ABCA9 all being "High"
joint_high_query <- querygrain(bn, nodes=c("BTNL9", "CD300LG", "IGSF10", "ABCA9"),
type="joint")
# Extract the probability of all genes being "High"
p_all_high <- joint_high_query["High", "High", "High", "High"]
print(paste("Probability of all four genes having high expression levels: ", p_all_high))
# Query conditional probability of having cancer given CD300LG = High and BTNL9 = Low
cancer_query <- querygrain(bn, nodes="class",
evidence=list(CD300LG="High", BTNL9="Low"),
type="conditional")
# Extract the probability of class = Cancer
p_cancer_given_cd300lg_high_btln9_low <- cancer_query["Cancer"]
print(paste("Probability of having cancer when CD300LG is high and BTNL9 is low: ",
p_cancer_given_cd300lg_high_btln9_low))
# Load only in-syllabus libraries from provided practicals
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
# Required for Bayesian Network structure learning and inference
library(bnlearn)
library(pcalg)
library(Rgraphviz)
library(rmarkdown)
library(tinytex)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
# Load required packages
library(bnlearn)
library(pcalg)
library(Rgraphviz)
library(rmarkdown)
library(tinytex)
# Load the dataset
gene_data <- read.csv("BRCA_RNASeqv2_top50.csv", header = TRUE)
# Remove the class variable (normal/cancer labels) as instructed
gene_data_noclass <- gene_data[, -which(names(gene_data) == "class")]
# Display the dimensions of the data
dim(gene_data_noclass)
# Prepare sufficient statistics for continuous data
suffStat <- list(C = cor(gene_data_noclass), n = nrow(gene_data_noclass))
# Apply the PC algorithm
pc.fit <- pc(suffStat = suffStat, indepTest = gaussCItest, alpha = 0.01, labels = colnames(gene_data_noclass))
# Plot the resulting CPDAG (Completed Partially Directed Acyclic Graph)
plot(pc.fit@graph)
# Find the index of ABCA9 gene
abca9_index <- which(colnames(gene_data_noclass) == "ABCA9")
# Estimate causal effects using IDA
ida_results <- ida(1:ncol(gene_data_noclass), abca9_index, cov(gene_data_noclass), pc.fit@graph)
# Find the index of ABCA9 gene
abca9_index <- which(colnames(gene_data_noclass) == "ABCA9")
# Create empty vector to store effects
ida_results <- numeric(ncol(gene_data_noclass))
# Loop through all potential cause genes (excluding ABCA9 itself)
for (i in 1:ncol(gene_data_noclass)) {
if (i == abca9_index) {
ida_results[i] <- 0  # No self-effect
} else {
ida_val <- tryCatch(
{
ida(i, abca9_index, cov(gene_data_noclass), pc.fit@graph, method = "local")
},
error = function(e) NA
)
ida_results[i] <- ifelse(is.null(ida_val), NA, ida_val)
}
}
# Create a table of causal effects
causal_effects <- data.frame(Gene = colnames(gene_data_noclass), Effect = ida_results)
# Rank by the absolute value of causal effects
causal_effects$AbsEffect <- abs(causal_effects$Effect)
causal_effects <- causal_effects[order(-causal_effects$AbsEffect), ]
# Display top 10 causes
head(causal_effects, 10)
# Find the index of EBF1 gene
ebf1_index <- which(colnames(gene_data_noclass) == "EBF1")
# Apply PC-simple algorithm (local causal discovery)
pcsimple_ebf1 <- pcSelect(gene_data_noclass[, ebf1_index], gene_data_noclass[, -ebf1_index], alpha = 0.05)
# Extract genes in Markov Blanket
mb_genes <- colnames(gene_data_noclass)[-ebf1_index][which(pcsimple_ebf1$G)]
# Display results
mb_genes
# Run IAMB to find Markov Blanket of EBF1
iamb_ebf1 <- learn.mb(gene_data_noclass,"EBF1", method = "iamb", alpha=0.01)
iamb_ebf1
# Run IAMB to find Markov Blanket of EBF1
iamb_ebf1 <- mb(gene_data_noclass,"EBF1", method = "iamb", alpha=0.01)
# Run IAMB to find Markov Blanket of EBF1
iamb_ebf1 <- learn.mb(gene_data_noclass,"EBF1", method = "iamb", alpha=0.01)
iamb_ebf1
plot(pc.fit@graph)
# Discretise using global mean as threshold (binary: High/Low)
threshold <- mean(as.matrix(gene_data_noclass))
# Discretise genes
disc_genes <- gene_data_noclass
for (col in colnames(disc_genes)) {
disc_genes[[col]] <- ifelse(disc_genes[[col]] > threshold, "High", "Low")
}
# Combine with class label
disc_data <- cbind(disc_genes, class = as.factor(gene_data$class))
View(disc_data)
# Discretise using global mean as threshold (binary: High/Low)
threshold <- mean(as.matrix(gene_data_noclass))
# Discretise genes
disc_genes <- gene_data_noclass
for (col in colnames(disc_genes)) {
disc_genes[[col]] <- ifelse(disc_genes[[col]] > threshold, "High", "Low")
}
# Combine with class label
disc_data <- cbind(disc_genes, class = as.factor(gene_data$class))
View(disc_data)
# Prepare numeric version for PC-simple
disc_data_classnum <- disc_data
disc_data_classnum$class <- as.numeric(disc_data_classnum$class)
# Run PC-simple to find PC set of 'class'
pc_class <- pcSelect(disc_data_classnum$class,
disc_data_classnum[, -which(names(disc_data_classnum) == "class")],
alpha = 0.05)
# Compute the average expression value across all genes and all samples
overall_mean <- mean(as.matrix(gene_data_noclass))
# Discretise genes into binary (0 = Low, 1 = High) based on overall mean
disc_genes <- gene_data_noclass
for (col in colnames(disc_genes)) {
disc_genes[[col]] <- ifelse(disc_genes[[col]] > overall_mean, 1, 0)
}
# Combine discretised gene data with the original class label
disc_data <- cbind(disc_genes, class = as.factor(gene_data$class))
View(disc_data)
# Prepare numeric version for PC-simple
disc_data_classnum <- disc_data
disc_data_classnum$class <- as.numeric(disc_data_classnum$class)
# Run PC-simple to find PC set of 'class'
pc_class <- pcSelect(disc_data_classnum$class,
disc_data_classnum[, -which(names(disc_data_classnum) == "class")],
alpha = 0.05)
pc_genes <- colnames(disc_data_classnum)[-which(colnames(disc_data_classnum) == "class")][which(pc_class$G)]
pc_genes
View(pc_class)
set.seed(42)
folds <- createFolds(disc_data$class, k = 5)
acc_all <- c()
acc_pc <- c()
for (i in 1:5) {
train_idx <- unlist(folds[-i])
test_idx <- unlist(folds[i])
# Full model
model_all <- naiveBayes(class ~ ., data = disc_data[train_idx, ])
pred_all <- predict(model_all, disc_data[test_idx, ])
acc_all[i] <- mean(pred_all == disc_data[test_idx, ]$class)
# PC model
model_pc <- naiveBayes(x = disc_data[train_idx, pc_genes], y = disc_data[train_idx, ]$class)
pred_pc <- predict(model_pc, disc_data[test_idx, pc_genes])
acc_pc[i] <- mean(pred_pc == disc_data[test_idx, ]$class)
}
# Report average accuracy
mean(acc_all)
mean(acc_pc)
# Select relevant genes for the Bayesian network
disc_selected <- disc_data[, c("CD300LG", "BTNL9", "ABCA9", "class")]
# Compute CPTs using bnlearn tables
cpt_cd300lg <- table(disc_selected$CD300LG) / nrow(disc_selected)
cpt_btnl9_given_cd300lg <- prop.table(table(disc_selected$BTNL9, disc_selected$CD300LG), margin = 2)
cpt_abca9_given_cd300lg <- prop.table(table(disc_selected$ABCA9, disc_selected$CD300LG), margin = 2)
cpt_class_given_cd300lg_btnl9 <- prop.table(table(disc_selected$class, disc_selected$CD300LG, disc_selected$BTNL9), margin = c(2,3))
# Display CPTs
cpt_cd300lg
cpt_btnl9_given_cd300lg
cpt_abca9_given_cd300lg
cpt_class_given_cd300lg_btnl9
View(disc_selected)
View(gene_data)
View(gene_data)
# Select relevant genes for the Bayesian network
disc_selected <- disc_data[, c("CD300LG", "BTNL9", "IGSF10", "ABCA9", "class")]
# Compute CPTs
cpt_cd300lg <- table(disc_selected$CD300LG) / nrow(disc_selected)
cpt_btnl9_given_cd300lg <- prop.table(table(disc_selected$BTNL9, disc_selected$CD300LG), margin = 2)
cpt_class_given_cd300lg <- prop.table(table(disc_selected$class, disc_selected$CD300LG), margin = 2)
cpt_igsf10_given_class <- prop.table(table(disc_selected$IGSF10, disc_selected$class), margin = 2)
cpt_abca9_given_igsf10_btnl9 <- prop.table(table(disc_selected$ABCA9, disc_selected$IGSF10, disc_selected$BTNL9), margin = c(2, 3))
# Display CPTs
cpt_cd300lg
cpt_btnl9_given_cd300lg
cpt_class_given_cd300lg
cpt_igsf10_given_class
cpt_abca9_given_igsf10_btnl9
View(disc_selected)
# Compute P(CD300LG=1) * P(BTNL9=1|CD300LG=1) * P(class=C|CD300LG=1) * P(IGSF10=1|class=C) * P(ABCA9=1|IGSF10=1, BTNL9=1)
p_cd300lg_1 <- cpt_cd300lg["1"]
p_btnl9_1_given_cd300lg_1 <- cpt_btnl9_given_cd300lg["1", "1"]
p_class_c_given_cd300lg_1 <- cpt_class_given_cd300lg["C", "1"]
p_igsf10_1_given_class_c <- cpt_igsf10_given_class["1", "C"]
p_abca9_1_given_igsf10_1_btnl9_1 <- cpt_abca9_given_igsf10_btnl9["1", "1", "1"]
p_joint_all_high <- p_cd300lg_1 * p_btnl9_1_given_cd300lg_1 * p_class_c_given_cd300lg_1 * p_igsf10_1_given_class_c * p_abca9_1_given_igsf10_1_btnl9_1
p_joint_all_high
# Extract P(class = C | CD300LG = 1) directly from CPT
p_class_c_given_cd300lg_1 <- cpt_class_given_cd300lg["C", "1"]
p_class_c_given_cd300lg_1
